


## id関数


Haskellにはid関数と呼ばれる特別な関数があります。

この関数の動作内容はとてもシンプルで、「受け取った内容を、そのまま返す」といった内容です。

```hs
:t id
id :: a -> a
```




## 恒等写像

一見意味がない関数に見えますが、このid関数は数学的な視点だと「恒等写像」と呼ばれるとても重要な関数なのです。

まず、この「id」関数という名前の由来は、「恒等写像」の英訳である「identity map」から来ています。

> （数学）始域と終域が同一で、入力をそのまま出力として返す写像。ある集合 X の任意の要素 x ∈ X に対して、 x ∈ X を返す写像 f: X → X

> 恒等写像を表す記号には、id や 1 が使われる。集合 A に対する恒等写像を idA や 1A と表す。

<img src="https://risalc.info/img/identity_map_defid_00.webp">

from https://risalc.info/src/identity-map.html



## id関数の使い道1: foldl関数による関数の合成

foldl関数は`reduce`関数とほぼ同義です。

引数は

- 関数
- 初期値
- 配列

の三つをとり、畳み込みを行います。

具体例を見てみましょう。

```hs
foldl (+) 0 [2, 3, 4]
> 9
```

上記の例では

- 関数 (+)
- 初期値 0
- 配列 [2,3,4]

であり、初期値0に対して、各配列の要素を加算し、2+3+4を計算しました。


上記は実数と実数の配列の演算でしたが、この`foldl`関数は複数の関数の合成にも使えます。
この際、**id関数はfoldl関数の合成の初期値として必要なのです**

```hs
let calc = foldl (.) foldl [ (+3), (-2), negate]
calc 5
> -4
```

from https://jxck.hatenablog.com/entry/20120626/1340724913



## id関数の使い道：何もしたくないとき


`map`関数は関数と配列を引数にとり、配列のすべての要素に関数を実行した結果を新しい配列として返します。

例えば、以下の二つの例は「1を加算するsucc関数」と「独自に作成した平方数を返すsquare関数」の二つを「配列[1,2,3,4,5]」に適応しています。


```hs
square :: Int -> Int
square x = x * x

main :: IO ()
main = do print $ map succ [1, 2, 3, 4, 5]    -- 出力: [2, 3, 4, 5, 6]
          print $ map square [1, 2, 3, 4, 5]  -- 出力: [1, 4, 9, 16, 25]
```

ところで、「配列に何か演算を施さず、そのままの値を返却したい」場合、どうすればよいでしょうか？
`if`文を用意して条件分岐で対応するのも手かもしれませんが、`id`関数を使用してそのままの値を返却させることもできます。

```hs
square :: Int -> Int
square x = x * x

main :: IO ()
main = do print $ map id [1, 2, 3, 4, 5]      -- 出力: [1, 2, 3, 4, 5]
```






















