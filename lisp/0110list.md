

## lispで配列を作成する方法

Lispで配列を作成するには、`make-array`関数を使用します。例えば、次のようにして3x3の整数配列を作成できます。


```lisp
(setq my-array (make-array '(3 3) :initial-element 0))
```


ここで、`'(3 3)`は配列の寸法を指定し、`:initial-element`は配列内の各要素の初期値を指定します。上記の例では、配列のすべての要素が0で初期化されます。

配列の要素にアクセスするには、`aref`関数を使用します。たとえば、上記の配列の中央の要素にアクセスするには、次のようにします。


```lisp
(aref my-array 1 1)
```

これは、my-array配列の2行目、2列目の要素を返します。

配列の要素を設定するには、`setf`と`aref`を組み合わせて使用します。たとえば、上記の配列の左上の要素に1を設定するには、次のようにします。

```lisp
(setf (aref my-array 0 0) 1)
```

これで、my-array配列の最初の要素は1になります。

## ジェネリックプログラミングについて

上記の`setf`と`aref`の組み合わせは**ジェネリックプログラミング**と呼ばれてます。

**これは、多くの場合、データ構造（配列、リスト、文字列などなど）から値を取り出すコードと、値を入れるコードが同じ形でかけるということだ。**

```lisp
(setf foo (list 'a 'b 'c))
> A B C

(second foo)
> B

(setf (second foo) 'z)
> Z

foo
> (A Z C)
```

期待の通り、`(second foo)`はBを返す。しかし、`(second foo)`をsetfコマンドに渡すと、それはBがどこから来るのかを知っていて、式（second foo）をあたかもその変数の場所を指す変数であるかのように扱う。

setfは「この最初の引数の値はどこから来たのだろう」と自問し、fooの二番目の値(second)であると発見し、その場所の値を変更する。


## 配列とリストの違い

Lispにおいて、配列とリストは異なるデータ構造であり、異なる目的に使用されます。

配列は、同じデータ型の要素を保持するために使用されます。要素には整数、文字、浮動小数点数、配列、または他のオブジェクトなどが含まれることができます。配列は、メモリ上に連続したブロックとして配置され、要素へのアクセスが高速です。また、要素の順序が保持されます。配列は、`make-array`関数を使用して作成されます。

リストは、異なるデータ型の要素を保持するために使用されます。要素には整数、文字、浮動小数点数、配列、他のリスト、または他のオブジェクトなどが含まれることができます。リストは、要素のペア（consセル）から構成され、要素の順序が保持されます。リストは、`cons`関数を使用して作成され、要素を先頭に追加することで拡張されます。

配列とリストの違いを簡単にまとめると、配列は同じデータ型の要素を連続したメモリ領域に保持し、要素の順序が保持されるデータ構造であり、リストは異なるデータ型の要素をconsセルで保持し、要素の順序が保持されるデータ構造であると言えます。

