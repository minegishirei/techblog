

## サービスベースアーキテクチャとは

サービスベースアーキテクチャは、マイクロサービスアーキテクチャの要素もある、分散型のアーキテクチャだ。

しかし、マイクロサービスやイベント駆動のタイプに見受けられる複雑さやコストがなく、多くのビジネスアプリケーションで選択されている。


<img src="https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2004service_base_arch/service_base_arch.png?raw=true">


## 参考

<img src="https://m.media-amazon.com/images/I/51-RoANBXoL._SX379_BO1,204,203,200_.jpg">

https://canvas.gu.se/files/4891694/download?download_frd=1

https://www.amazon.co.jp/-/en/Neal-Ford/dp/1492043451



## サービスベースのアーキテクチャスタイル

サービスベースのアーキテクチャの基本的なトポロジは分散型のマイクロなレイヤー形式をとる。

構成要素は3つ存在し

- 個別にビルドされたユーザーインターフェース

- 個別にビルドされたリモートのバックエンドサービス

- モノリシックなデータベース

これらがユーザー側から見て順にレイヤーとなり構成される。

<img src="https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2004service_base_arch/service_base_arch.png?raw=true">


### サービスベースアーキテクチャのインスタンスの数

AWS上でこのアーキテクチャを採用する場合、サービスベースアーキテクチャのインスタンス数は基本的に1つだ。

しかし、**スケーラビリティや耐障害性、スループットの必要性に応じて、ドメインサービスのインスタンスが複数存在することもある。**
その場合、**ユーザーインターフェースとドメインサービスの間**に**何らかの負荷分散機能を必要**とする。

AWSの場合は、Elastic Load Balancingなどの活用が候補に上がるだろう。

<img src="https://d1.awsstatic.com/Digital%20Marketing/House/1up/products/elb/Product-Page-Diagram_Elastic-Load-Balancing_ALB_HIW%402x.cb3ce6cfd5dd549c99645ed51eef9e8be8a27aa3.png">

[AWS-EBS公式ページより](https://aws.amazon.com/jp/elasticloadbalancing/)

*ELB (Elastic Load Balancing) は、アプリケーションへのトラフィックを、1 つまたは複数のアベイラビリティーゾーン (AZ) 内の複数のターゲットおよび仮想アプライアンスに自動的に分散します。*

### サービスベースアーキテクチャの通信方式

ユーザーインターフェースからバックエンドにあるサービスの通信方式には、一般的にAPIが使用される。

しかし、

- メッセージング

- リモートプロシージャーコール(RPC)

- SOAP

なども候補に入れて良い

### サービスベースアーキテクチャのデータベース

<img src="https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2004service_base_arch/service_base_arch.png?raw=true">

一般的に、中央でデータベースを構えているという点が、このアーキテクチャの重要な側面である。
これより、**元来使われてきたモノシリックなサービスでのSQLクエリの結合を活用できる。**

サービスが少ない場合は、データベースへの接続が問題になることは滅多にない。
しかし、**開発におけるデータベースの変更はリスクを伴う**




## サンプル例

ユーザーインターフェースの数、データベースの数、サービスの数は簡単に変化する

### ユーザーインターフェースの数が変化するパターン

<img src="https://camo.githubusercontent.com/d453f04a35c4096e651f5e52891c1f71c92ca8d59b916504986a871fff9fa2bb/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313330322e706e67">




### データベースが複数存在するパターン

<img src="https://camo.githubusercontent.com/9488fa07f6f2a3c2909b603fa575051d9f8b4cd55776dafa776bf0005a3562d2/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313330332e706e67">

単一のモノリシックデータベースを個別のデータベースに分割する機会が存在する可能性があります。各ドメインサービスに一致するドメインスコープのデータベース（マイクロサービスと同様）にまで及ぶ場合もあります。


### リバースプロキシ

次のように、ユーザーインターフェイスとサービスの間にリバースプロキシまたはゲートウェイで構成される構成を追加することもできます。

これは

- ドメインサービス機能を外部システムに公開する場合、

- 共有の横断的関心事を統合してユーザーインターフェイスの外部に移動する場合

に適応する

<img src="https://camo.githubusercontent.com/bb0e5ed68554c83a4c152d2c9d640e9150931170907bbe4a0ff6850d446325bc/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313330342e706e67">

ユーザーインターフェイスとドメインサービスの間にAPIレイヤーを追加する



## データベースの変更

ここまで紹介した通り、ほとんどの場合でデータベースの数は一つか、多くて二つ程度である。

少ないデータベースは、コミットとロールバックを含む通常の（アトミック性、一貫性、分離、耐久性）データベーストランザクションを使用して、
単一のドメインサービス内のデータベースの整合性を確保します。

一貫性を保つことができるのが少ないデータベースのメリットである。

しかしこの場合、**データベースの変更は全てのサービスへの影響を意味する**


このデータベース変更の影響とリスクを軽減する1つの方法は、データベースを論理的にパーティション化し、フェデレーション共有ライブラリを介して論理的なパーティション化を明示することです。

<img src="https://camo.githubusercontent.com/082f8e6a779f6fa2ea8175ad94a6fbc4000b7a021b9f851fb58f5417db9866f9/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313330372e706e67">



## メリットとデメリット

このアーキテクチャは「ドメイン管理方式」である。（技術管理方式ではない）

したがってあるサービスの改修が入った場合、その他の改修を行う必要はなく、関係のないコンポーネントのビルドも防ぐことができる。

サービス単位でテストを組むこともできるため、ソフトウェアの品質を高く保つことができる。

まとめると以下の通り

- サービスごとに分割されているため、迅速な変更が可能

- サービスには範囲が区切られているため、テストも対象のサービス内部に抑えられる。

- より少ないリスクでデプロイできる。

デメリットは「コストが高くなる可能性がある」こと

小規模なアプリケーションでは費用対効果が出ないこともある。


## まとめ

このアーキテクチャはほとんどが星4で評価されている。



<img src="https://camo.githubusercontent.com/6428bd5a21cb28c9f5c6b14beee4a43dc10b7fa5b7e561e29ee656417e9ef752/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313330392e706e67">



## 備考

title:サービスベースアーキテクチャのメリットとデメリット

description:このアーキテクチャは「ドメイン管理方式」である。（技術管理方式ではない）したがってあるサービスの改修が入った場合、その他の改修を行う必要はなく、関係のないコンポーネントのビルドも防ぐことができる。サービス単位でテストを組むこともできるため、ソフトウェアの品質を高く保つことができる。

img:https://camo.githubusercontent.com/6a3bb5e7744ff17abe176ac6b7f4e9ea5727635e155a759d7be7faa97ef6dc0f/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313330312e706e67

category_script:page_name.startswith("2")



