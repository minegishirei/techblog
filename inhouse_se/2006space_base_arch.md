


## スペースベースアーキテクチャが解決する課題

ほとんどのWebアプリケーションは、次のような一般的なリクエストフローに従っている。
ブラウザからの要求は、Webサーバー、アプリケーションサーバーを経て、最後にデータベースサーバーに処理が移る。

このパターンは少数のユーザーには最適ですが、ユーザーの負荷が増えると、Webサーバー層、次にアプリケーションサーバー層、最後にデータベースサーバー層でボトルネックが発生し始めます。

ユーザー負荷の増加に基づくボトルネックへの通常の対応は、Webサーバーをスケールアウトすることです。
これは比較的簡単で安価であり、ボトルネックの問題に対処するために機能する場合がありますが、ボトルネックがアプリケーションサーバーに移動します。

そうしてアプリケーションサーバーの負荷をどうにかして減らせたとしても、**最終的にはデータベースに負荷が移動するだけで根本的な解決にはなりません。**

<img src="https://www.ulsystems.co.jp/archives/assets/topics_development_016_02.gif">

https://www.ulsystems.co.jp/archives/022.html

```
DBは業務に必要な情報を集約的に保持していることに価値があります。
逆に、DBにデータを分散して保持させることは困難だとも言えます。

もちろん、現在リリースされているRDBMS製品は、パーティションやレプリケーションといったデータを物理的に分散させる機能を提供しています。
しかし、DBの利用者から見ると、論理的には一元管理されているものとしてデータにアクセスしたいものです。
例えば、「顧客マスタ」データが物理的にはマシンAとマシンBに分散配置されているとしても、
「顧客マスタ」を扱うプログラムはマシンAとマシンB両方のデータを透過的に扱いたいはずです。
```


この問題を解消するのが**スペースベースアーキテクチャ**です。

スペースベースアーキテクチャには、高いスケーラビリティと弾力性、並列処理といった問題に対応できる特性を持ちます。

特に、同時アクセス数ユーザーが予測できない場合に有効です。




## スペースベースアーキテクチャの概要

<img src="https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2006space_base_arch/space_base_arch.png?raw=true">

スペースベースアーキテクチャの特徴は、**アプリの標準的なトランザクションに中央のデータベースが関与しないこと**です。
これにより、**データベースのトランザクションというボトルネックが解消されアプリケーションのスケーラビリティは無限になります。**

中央のデータベースとの連携ではなく、各処理ユニットがメモリ内部にデータを持つのです。
そして、メモリ内部のデータが更新されると、更新情報が非同期的に他の処理ユニットに送られ、結果的に複製されます。

これらのメモリ内部でのデータ共有の技術を**タプルスペース**と呼ぶのです。

スペースベースのアーキテクチャのスペースとは、タプルスペースに由来します。

中央データベースをシステムの同期制約として削除し、**代わりに複製されたメモリ内データグリッドを活用する**ことで、高いスケーラビリティ、高い弾力性、および高いパフォーマンスが実現されます。

ユニット処理装置は、ユーザーの負荷が増減するにつれて動的に起動およびシャットダウンするため、スケーラビリティーが確保されるのです。




## スペースベースアーキテクチャの構成要素

<img src="https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2006space_base_arch/space_base_arch.png?raw=true">

- 処理ユニット(Processing Unit)

アプリケーションコード、メモリ内部のデータグリッド、データ複製エンジンを含む。

- データリーダー(DataReader),データライター(DataWriter)

非同期方式で処理ユニットのデータを受け取り、中央のデータベースにメッセージを送る

- 仮想ミドルウェア(Virtualized Middleware)

処理ユニットの管理・調節に使用される



## スペースベースアーキテクチャの処理ユニット

### アプリケーションコード

ここには通常、webフレームワークなどのバックエンドのビジネスロジックが含まれており、ある種一つのアプリケーションが完成している。

また大規模なアプリケーションでは、以下のように処理ユニットが複数種類に分割される可能性がある。

<img src="https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2006space_base_arch/space_base_arch_somekind.png?raw=true">

例えば、個人情報の漏出ニュースが流れ会員ページへのアクセスが集中する場合は、**Profile Process Unit**を複製することでバーストに耐えることができる。

### インメモリデータグリッドとレプリケーションエンジン

処理ユニットには通常、**インメモリデータグリッド**と**レプリケーションエンジン**も含まれる。

- Hazelcast

- Apache Ignite

- Oracle Coherence

これらの製品を通じて実装されるものである。

<img src="https://www.gridgain.com/sites/default/files/inline-images/Figure1_16.png">

https://www.gridgain.com/resources/blog/using-gridgainr-kafkar-connector




## 仮想ミドルウェア

データの同期やリクエスト処理の様々な側面を制御するアーキテクチャ内部のインフラストラクチャに関する問題を処理する。

この仮想ミドルウェアを構成するのは次の4つの要素からなる

- メッセージンググリッド(役割はロードバランサー)

- データグリッド(メモリデータの中央)

- 処理グリッド

- デプロイメントグリッド


### メッセージンググリッド

入力されたリクエストやセッションの状態を管理する

ユーザーからメッセージを受け取ると、どのアクティブな処理コンポーネントがリクセストを受信できるかし、それらの処理ユニットの1つに要求を転送します。

メッセージンググリッドの複雑さは、単純なラウンドロビンアルゴリズムから、どの要求がどの処理ユニットによって処理されているかを追跡する、より複雑な次に利用可能なアルゴリズムにまで及ぶ可能性があります。

このコンポーネントは通常、負荷分散機能を備えた一般的なWebサーバー（HA ProxyやNginxなど）を使用して実装されます。

<img src="https://camo.githubusercontent.com/ca9bf1b045fdf0d80d912dbec1eddd7ad40e96940bf4836bbff23dd5e9a3bbf9/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530342e706e67">


### データグリッド

**データグリッドコンポーネントは、このアーキテクチャスタイルでおそらく最も重要で重要なコンポーネントです。**

最新の実装では、データグリッドは複製されたキャッシュとして処理ユニット内にのみ実装されます。

**メッセージンググリッドは使用可能な任意の処理ユニットに要求を転送できるため、各処理ユニットのメモリ内データグリッドにまったく同じデータが含まれていることが不可欠です。** 図15-5は、処理装置間の同期データ複製を示していますが、実際には、これは非同期で非常に迅速に実行されます。

<img src="https://camo.githubusercontent.com/c2ac95e0dfc03e128a8b2785ee1034273f6cdc6f191d1b91c3c8ead375ca5b73/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530352e706e67">


### 処理グリッド

図15-6に示す処理グリッドは、仮想化ミドルウェア内のオプションのコンポーネントであり、**単一のビジネス要求に複数の処理装置が含まれている場合に、組織化された要求処理を管理します。**

たとえば、注文処理ユニットと支払い処理ユニット間の調整を必要とする要求が着信した場合、これら2つの処理ユニット間の要求を**仲介および調整する**のは処理グリッドです。

<img src="https://camo.githubusercontent.com/6bbaaf20b54f5468ef0bc028294f134383bd489143c2b8237735146bb4b7d9cc/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530362e706e67">


### デプロイメントマネージャー

デプロイメント・マネージャー・コンポーネントは、負荷条件に基づいて処理装置インスタンスの動的な始動とシャットダウンを管理します。

このコンポーネントは、応答時間とユーザーの負荷を継続的に監視し、負荷が増加すると新しい処理装置を起動し、負荷が減少すると処理装置をシャットダウンします。

これは、アプリケーション内で可変のスケーラビリティ（弾性）のニーズを達成するための重要なコンポーネントです。


## データポンプ

データポンプは、データベース内のデータを更新する別のプロセッサにデータを送信する方法です。

データポンプは通常、メッセージング(JSON,XMLなど)を使用して実装されます。

<img src="https://camo.githubusercontent.com/742cf2ca554be7b1bd94c03d166450026aeff544d3840da02decabcc8e60ef83/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530372e706e67">


## データライター

データライターコンポーネントは、データポンプからのメッセージを受け取り、データポンプのメッセージに含まれる情報でデータベースを更新します。データライターは、サービス、アプリケーション、またはデータハブ（Ab Initioなど）として実装できます。

ドメインベースのデータライターには、受け入れるデータポンプの数に関係なく、特定のドメイン（顧客など）内のすべての更新を処理するために必要なすべてのデータベースロジックが含まれています。


<img src="https://camo.githubusercontent.com/528809b4f973b14867c84b9b8ac0902cbcbe697d6acf37e109be3e8a10b4507f/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530382e706e67">

また、データポンプ一つに対してデータライターが一つつくこともあります。

<img src="https://camo.githubusercontent.com/31d7c16ebd877d81bf94e5f688fed64e653e3af7aa390bb5962ec0e5b0f49aac/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530392e706e67">


## データリーダー

データリーダーはデータベースからデータを読み取り、リバースデータポンプを介して処理ユニットに送信する責任を負います。スペースベースのアーキテクチャでは、データリーダーは、

- 同じ名前のキャッシュのすべての処理装置インスタンスのクラッシュ、

- 同じ名前のキャッシュ内のすべての処理装置の再配置、

- またはに含まれていないアーカイブデータの取得の3つの状況

のいずれかでのみ呼び出されます。

<img src="https://camo.githubusercontent.com/4466a966582f88dcc767a97e2cba0b581ad5fd6cfcd040d8ce6a8c6aa0af6a67/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313531302e706e67">

すべてのインスタンスがダウンした場合（システム全体のクラッシュまたはすべてのインスタンスの再デプロイが原因）、データをデータベースから読み取る必要があります（スペースベースのアーキテクチャでは一般的に回避されます）。


## データリーダーとデータライターについて

この二つは本質的にはデータ抽出層なるものを形成する。

あるいは、データアクセス層となるか。

データアクセス層とは処理ユニットがデータベースの基礎となるデータ構造に結合されており、データリーダーとライターを用いてアクセスするだけのものである。

一方のデータ抽出層とは処理ユニットが個別のコンストラクトによってデータベースの基礎となるテーブル構造から切り離されていることを意味する。
一般的にスペースベースアーキテクチャではこちらを採用する。





## 備考



title:スペースベースアーキテクチャのメリットデメリット

description:スペースベースアーキテクチャの概要と構造、メリットとデメリットを解説します。

img:https://camo.githubusercontent.com/06d84761b5bd8b2e05794cd109093e10266d58990e1eefe002269ffd073d8c0b/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530322e706e67

category_script:page_name.startswith("2")




