


## スペースベースアーキテクチャが解決する課題

ほとんどのWebベースのビジネスアプリケーションは、いずれも一般的なリクエストフローに従っている。
ブラウザからの要求は、Webサーバー、アプリケーションサーバー、最後にデータベースサーバーの順にヒットします。

このパターンは少数のユーザーには最適ですが、ユーザーの負荷が増えると、最初にWebサーバー層、次にアプリケーションサーバー層、最後にデータベースサーバー層でボトルネックが発生し始めます。

ユーザー負荷の増加に基づくボトルネックへの通常の対応は、Webサーバーをスケールアウトすることです。
これは比較的簡単で安価であり、ボトルネックの問題に対処するために機能する場合があります。

ただし、ユーザーの負荷が高いほとんどの場合、Webサーバーレイヤーをスケールアウトすると、ボトルネックがアプリケーションサーバーに移動します。
アプリケーションサーバーのスケーリングは、Webサーバーよりも複雑で費用がかかる可能性があり、通常、ボトルネックをデータベースサーバーに移すだけです。


これは、スケーリングがさらに困難で費用がかかります。データベースをスケーリングできたとしても、最終的には三角形のトポロジになります。三角形の最も広い部分がWebサーバー（スケーリングが最も簡単）で、最小の部分がデータベース（スケーリングが最も難しい）です。

<img src="https://camo.githubusercontent.com/be7cac73085974c7322588ad5a441505c6726ad6b7fd74479ed200d4c16c022b/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530312e706e67">

この状態を解消するのが**スペースベースアーキテクチャ**です

## スペースベースアーキテクチャの概要

スペースベースのアーキテクチャの名前は、タプルスペース共有メモリを介して通信する複数の並列プロセッサを使用する手法であるの概念に由来しています。

中央データベースをシステムの同期制約として削除し、**代わりに複製されたメモリ内データグリッドを活用する**ことで、高いスケーラビリティ、高い弾力性、および高いパフォーマンスが実現されます。


アプリケーションデータはメモリ内に保持され、すべてのアクティブな処理ユニット間で複製されます。処理装置がデータを更新すると、**通常は永続キューを使用したメッセージングを介して、そのデータをデータベースに非同期で送信します。**

処理装置は、ユーザーの負荷が増減するにつれて動的に起動およびシャットダウンするため、さまざまなスケーラビリティーに対応します。


## スペースベースアーキテクチャの構造

- 処理ユニット(Processing Unit)

アプリケーションコードを含むもの

この中にはメモリ内部のデータグリッドキャッシュとデータ複製エンジンが搭載されており、これらが仮想ミドルウェアとDataReader,DataWriterと連動する

- DataReader,DataWriter

非同期方式でデータを受け取り、データベースにメッセージを送る


- 仮想ミドルウェア(Virtualized Middleware)

処理ユニットの管理・調節に使用される


<img src="https://camo.githubusercontent.com/06d84761b5bd8b2e05794cd109093e10266d58990e1eefe002269ffd073d8c0b/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530322e706e67">



## スペースベースアーキテクチャの処理ユニット

ここには通常、webベースのコンポーネントやバックエンドのビジネスロジックが含まれる。

大規模なアプリケーションでは処理ユニットを複数に分割される可能性がある。

この処理ユニットではある種一つのアプリケーションが完成している。

<img src="https://camo.githubusercontent.com/fd09df1e5a7bdbc3e002e1d1624ef61d6ed3d31da333ee0b4d07b7927c73ee5a/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530332e706e67">

## 仮想ミドルウェア

データの同期やリクエスト処理の様々な側面を制御するアーキテクチャ内部のインフラストラクチャに関する問題を処理する。

この仮想ミドルウェアを構成するのは次の4つの要素からなる

- メッセージンググリッド

- データグリッド

- 処理グリッド

- デプロイメントグリッド


### メッセージンググリッド

入力されたリクエストやセッションの状態を管理する

ユーザーからメッセージを受け取ると、どのアクティブな処理コンポーネントがリクセストを受信できるかし、それらの処理ユニットの1つに要求を転送します。

メッセージンググリッドの複雑さは、単純なラウンドロビンアルゴリズムから、どの要求がどの処理ユニットによって処理されているかを追跡する、より複雑な次に利用可能なアルゴリズムにまで及ぶ可能性があります。

このコンポーネントは通常、負荷分散機能を備えた一般的なWebサーバー（HA ProxyやNginxなど）を使用して実装されます。

<img src="https://camo.githubusercontent.com/ca9bf1b045fdf0d80d912dbec1eddd7ad40e96940bf4836bbff23dd5e9a3bbf9/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530342e706e67">


### データグリッド

**データグリッドコンポーネントは、このアーキテクチャスタイルでおそらく最も重要で重要なコンポーネントです。**

最新の実装では、データグリッドは複製されたキャッシュとして処理ユニット内にのみ実装されます。

**メッセージンググリッドは使用可能な任意の処理ユニットに要求を転送できるため、各処理ユニットのメモリ内データグリッドにまったく同じデータが含まれていることが不可欠です。** 図15-5は、処理装置間の同期データ複製を示していますが、実際には、これは非同期で非常に迅速に実行されます。

<img src="https://camo.githubusercontent.com/c2ac95e0dfc03e128a8b2785ee1034273f6cdc6f191d1b91c3c8ead375ca5b73/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530352e706e67">


### 処理グリッド

図15-6に示す処理グリッドは、仮想化ミドルウェア内のオプションのコンポーネントであり、**単一のビジネス要求に複数の処理装置が含まれている場合に、組織化された要求処理を管理します。**

たとえば、注文処理ユニットと支払い処理ユニット間の調整を必要とする要求が着信した場合、これら2つの処理ユニット間の要求を**仲介および調整する**のは処理グリッドです。

<img src="https://camo.githubusercontent.com/6bbaaf20b54f5468ef0bc028294f134383bd489143c2b8237735146bb4b7d9cc/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530362e706e67">


### デプロイメントマネージャー

デプロイメント・マネージャー・コンポーネントは、負荷条件に基づいて処理装置インスタンスの動的な始動とシャットダウンを管理します。

このコンポーネントは、応答時間とユーザーの負荷を継続的に監視し、負荷が増加すると新しい処理装置を起動し、負荷が減少すると処理装置をシャットダウンします。

これは、アプリケーション内で可変のスケーラビリティ（弾性）のニーズを達成するための重要なコンポーネントです。


## データポンプ

データポンプは、データベース内のデータを更新する別のプロセッサにデータを送信する方法です。

データポンプは通常、メッセージング(JSON,XMLなど)を使用して実装されます。

<img src="https://camo.githubusercontent.com/742cf2ca554be7b1bd94c03d166450026aeff544d3840da02decabcc8e60ef83/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530372e706e67">


## データライター

データライターコンポーネントは、データポンプからのメッセージを受け取り、データポンプのメッセージに含まれる情報でデータベースを更新します。データライターは、サービス、アプリケーション、またはデータハブ（Ab Initioなど）として実装できます。

ドメインベースのデータライターには、受け入れるデータポンプの数に関係なく、特定のドメイン（顧客など）内のすべての更新を処理するために必要なすべてのデータベースロジックが含まれています。


<img src="https://camo.githubusercontent.com/528809b4f973b14867c84b9b8ac0902cbcbe697d6acf37e109be3e8a10b4507f/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530382e706e67">

また、データポンプ一つに対してデータライターが一つつくこともあります。

<img src="https://camo.githubusercontent.com/31d7c16ebd877d81bf94e5f688fed64e653e3af7aa390bb5962ec0e5b0f49aac/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530392e706e67">


## データリーダー

データリーダーはデータベースからデータを読み取り、リバースデータポンプを介して処理ユニットに送信する責任を負います。スペースベースのアーキテクチャでは、データリーダーは、

- 同じ名前のキャッシュのすべての処理装置インスタンスのクラッシュ、

- 同じ名前のキャッシュ内のすべての処理装置の再配置、

- またはに含まれていないアーカイブデータの取得の3つの状況

のいずれかでのみ呼び出されます。

<img src="https://camo.githubusercontent.com/4466a966582f88dcc767a97e2cba0b581ad5fd6cfcd040d8ce6a8c6aa0af6a67/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313531302e706e67">

すべてのインスタンスがダウンした場合（システム全体のクラッシュまたはすべてのインスタンスの再デプロイが原因）、データをデータベースから読み取る必要があります（スペースベースのアーキテクチャでは一般的に回避されます）。


## データリーダーとデータライターについて

この二つは本質的にはデータ抽出層なるものを形成する。

あるいは、データアクセス層となるか。

データアクセス層とは処理ユニットがデータベースの基礎となるデータ構造に結合されており、データリーダーとライターを用いてアクセスするだけのものである。

一方のデータ抽出層とは処理ユニットが個別のコンストラクトによってデータベースの基礎となるテーブル構造から切り離されていることを意味する。
一般的にスペースベースアーキテクチャではこちらを採用する。









title:スペースベースアーキテクチャとは何か？

description:スペースベースアーキテクチャの概要と構造、メリットとデメリットを解説します。

img:https://camo.githubusercontent.com/06d84761b5bd8b2e05794cd109093e10266d58990e1eefe002269ffd073d8c0b/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313530322e706e67

category_script:page_name.startswith("2")




