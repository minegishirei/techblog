




## なぜマイクロサービスアーキテクチャなのか？

### 再利用か分離か

まず、**コンポーネントの再利用性と分離は共存できない**

再利用を前提としてシステムを組む場合、アーキテクトはその再利用性を実現するために、
クラスの継承が発生する。
しかし、クラスAからクラスBへの継承には当然結合が発生する。
なぜならクラスBはクラスAの存在を前提としてプログラムが組んであるからだ。

このような依存関係のことを結合と呼ぶ。


### 再利用のメリットとデメリット

これまで多くの技術者は限られたリソースを有効活用するためにシステムの再利用性を重要視してきた。
しかし、システムの再利用性を重視するということは同時に結合を多く生み出してしまう。
結合を多く生み出すことは、**システムの一部分の変更を、予測できない怖い変化へと置き換わってしまう**

たとえば、クラスＡからクラスＢへ継承を行う場合、クラスＡの変更はクラスＢにも影響してしまう。
この継承が一世代のみであれば問題ないが、開発者の見えないところでクラスＣが存在し、クラスＢを継承していた場合、クラスＣは予想外の変更を受けることになる。

### 分離のメリット

クラスＡとクラスＢの間に継承関係が存在しない場合、再利用によるデメリットは発生しなくなる。
クラスＡの変更はクラスＢに届かないからだ。（当然クラスＣも変化は起きない）

**このように、コンポーネントとコンポーネントの分離には、システムの変更をよりポジティブなものにできる。**

同様のことはクラスレベルだけでなく、サーバーレベルでも発生する。


## マイクロサービスアーキテクチャの概要

以下はマイクロサービスの基本的なトポロジーである

<img src="https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2008microservice_arch/microservice_arch.png?raw=true">

マイクロサービスは分散アーキテクチャを形成し、各サービスは独自のプロセスで実行されます。
「各サービスのプロセス」とは元々は物理コンピューターを意味していましたが、すぐに仮想マシンとコンテナーに進化しました。

マイクロサービスのコアな価値観は疎な結合による**高度な分離**です。
各サービスでは、会社がやりたい事業をそのままシステム化しています。
例えば、ECサイトをマイクロサービス化する場合、注文受付サービス、在庫管理サービス、物量管理サービスの3つがマイクロサービスとしてひとつの仕事と責任をこなします。
そして、注文受付サービスの変更は在庫管理サービスに影響しないようにするのです。
**そのような高度な分離による変更可能性こそがマイクロサービスアーキテクチャの真価です。**

**マイクロサービスのコアな価値観は疎な結合です。**
そして疎な結合を求めるため、**再利用性をあきらめています。**

## マイクロサービスアーキテクチャの構成要素

<img src="https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2008microservice_arch/microservice_arch.png?raw=true">

マイクロサービスアーキテクチャの構成要素は非常にシンプルです。

- サービスの受付となるAPIレイヤー（NginxやApacheを使って実装されることもあります）

- 各サービス

この二つです。

また、**各サービスはそのサービスが成り立つために必要なすべてを持ちます。**

例えば

- データベース

- nginxなどのwebサービスシステム

- アプリケーションとビジネスロジック

- UIコンポーネント

などなどです。
そのサービスが必要なものはすべて自前で用意するのです。

この性質上、各サービスにて重複するビジネスロジック（会計期の計算ロジックや会社で設定する日付）が重複してもそれをよしとします。


### マイクロサービスアーキテクチャのサイドカーパターン

マイクロサービスアーキテクチャが高度な分離を目指すとしても、どうしてもサービス同士で結合したいパターンもあります。

例えば、**運用Tが各サービスを監視する必要があった場合**、各サービスに散らばったログ機能、モニタリング機能をどのように集計すればよいのでしょうか。

この場合は、マイクロサービスアーキテクチャのサイドカーパターンが回答としてあり得ます。

<img src="https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2008microservice_arch/microservice_arch_sidecar.png?raw=true">

サイドカーパターンでは**各サービスの内部に運用で必要な機能を共通のコンポーネントとして保有するという実装を行います。**

このサイドカー自体は共有インフラストラクチャーチームがソースの管理を行い、更新があればgit等で変更をpushし、各チームがpullすることで実装まで完了します。


### マイクロサービスアーキテクチャのフロントエンドの実装

マイクロサービスアーキテクチャは分離を推奨していますが、それはフロントエンドも含みます。

以前はWebアプリケーションがそのような分離されたUIを提供すること自体が不可能でした。

現在ではReactのようなコンポーネントベースのWebフレームワークが登場してきたため、**マイクロフロントエンド**とよばれるフロントエンドの実装方法が取られます。

マイクロフロントエンドは次のように、各サービスがフロントエンドの一部分であるコンポーネントを持ち、フロントエンドがそれを組み合わせて実装する形式のことです。

<img src="https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2008microservice_arch/microservice_arch_microfrontend.png?raw=true">

各サービスは自サービス用のユーザーインターフェースを提供し、フロントエンドはそれぞれのあサービスから提供されたUIコンポーネントを組み合わせて利用します。

開発者にはReactのようなWebフレームワークを使う選択肢から、(icestack)[https://micro-frontends.ice.work/]と呼ばれるマイクロフロント専用のフレームワークを使う手段もあります。

<img src="https://camo.githubusercontent.com/6d368e3b28e2e79600f066e72043a8ad434bfaf82be7f58db84d2733b4a3c843/68747470733a2f2f696d672e616c6963646e2e636f6d2f7466732f5442313637666965784431674b306a535a46735858626c645658612d313432312d313431362e706e67">



## 各サービスの粒度について

アーキテクトは、マイクロサービスのサービスの正しい粒度を見つけるのに苦労し、サービスを小さくしすぎるという間違いを犯すことがよくあります。

マイクロサービスで適切な粒度を決定するには次のことを肝に銘じてください。

**コンポーネントの分離を行うことで結合やトランザクションが増えるのであればそれは正しい粒度ではない**


## データの分離

制限付きコンテキストの概念によって推進されるマイクロサービスのもう1つの要件は、データの分離です。

他の多くのアーキテクチャスタイルは、永続性のために単一のデータベースを使用します。

マイクロサービスアーキテクチャは違います。

**統合ポイントとして使用される共有スキーマやデータベースなど、あらゆる種類の結合を回避しようとします。**

それぞれのサービスがデータベースを持つことに意味があるのです。




## 備考

title:マイクロサービスアーキテクチャのメリットとデメリット

description:マイクロサービスは分散アーキテクチャを形成し、各サービスは独自のプロセスで実行されます。これは元々は物理コンピューターを意味していましたが、すぐに仮想マシンとコンテナーに進化しました。

img:https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2008microservice_arch/microservice_arch.png?raw=true

category_script:( page_name.startswith("2") or page_name.startswith("1") )










