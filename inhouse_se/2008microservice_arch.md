




## なぜマイクロサービスアーキテクチャなのか？

### 再利用か分離か

まず、**コンポーネントの再利用性と分離は共存できない**

再利用を前提としてシステムを組む場合、アーキテクトはその再利用性を実現するために、
クラスの継承が発生する。
しかし、クラスAからクラスBへの継承には当然結合が発生する。
なぜならクラスBはクラスAの存在を前提としてプログラムが組んであるからだ。

このような依存関係のことを結合と呼ぶ。


### 再利用のメリットとデメリット

これまで多くの技術者は限られたリソースを有効活用するためにシステムの再利用性を重要視してきた。
しかし、システムの再利用性を重視するということは同時に結合を多く生み出してしまう。
結合を多く生み出すことは、**システムの一部分の変更を、予測できない怖い変化へと置き換わってしまう**

たとえば、クラスＡからクラスＢへ継承を行う場合、クラスＡの変更はクラスＢにも影響してしまう。
この継承が一世代のみであれば問題ないが、開発者の見えないところでクラスＣが存在し、クラスＢを継承していた場合、クラスＣは予想外の変更を受けることになる。

### 分離のメリット

クラスＡとクラスＢの間に継承関係が存在しない場合、再利用によるデメリットは発生しなくなる。
クラスＡの変更はクラスＢに届かないからだ。（当然クラスＣも変化は起きない）

**このように、コンポーネントとコンポーネントの分離には、システムの変更をよりポジティブなものにできる。**

同様のことはクラスレベルだけでなく、サーバーレベルでも発生する。


## マイクロサービスアーキテクチャの概要

以下はマイクロサービスの基本的なトポロジーである

<img src="https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2008microservice_arch/microservice_arch.png?raw=true">

マイクロサービスは分散アーキテクチャを形成し、各サービスは独自のプロセスで実行されます。
「各サービスのプロセス」とは元々は物理コンピューターを意味していましたが、すぐに仮想マシンとコンテナーに進化しました。

マイクロサービスのコアな価値観は疎な結合による**高度な分離**です。
各サービスでは、会社がやりたい事業をそのままシステム化しています。
例えば、ECサイトをマイクロサービス化する場合、注文受付サービス、在庫管理サービス、物量管理サービスの3つがマイクロサービスとしてひとつの仕事と責任をこなします。
そして、注文受付サービスの変更は在庫管理サービスに影響しないようにするのです。
**そのような高度な分離による変更可能性こそがマイクロサービスアーキテクチャの真価です。**

**マイクロサービスのコアな価値観は疎な結合です。**
そして疎な結合を求めるため、**再利用性をあきらめています。**

## マイクロサービスアーキテクチャの構成要素

<img src="https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2008microservice_arch/microservice_arch.png?raw=true">

マイクロサービスアーキテクチャの構成要素は非常にシンプルです。




## 各サービスの粒度について


アーキテクトは、マイクロサービスのサービスの正しい粒度を見つけるのに苦労し、サービスを小さくしすぎるという間違いを犯すことがよくあります。

そのため、有用な作業を行うには、サービス間に通信リンクを構築する必要があります。

マイクロサービスで適切な粒度を決定するには次のことを肝に銘じてください。

**コンポーネントの分離を行うことで結合が増えるのであればそれは正しい粒度ではない**


## データの分離

制限付きコンテキストの概念によって推進されるマイクロサービスのもう1つの要件は、データの分離です。

他の多くのアーキテクチャスタイルは、永続性のために単一のデータベースを使用します。

マイクロサービスアーキテクチャは違います。

**統合ポイントとして使用される共有スキーマやデータベースなど、あらゆる種類の結合を回避しようとします。**

それぞれのサービスがデータベースを持つことに意味があるのです。


## Devopsについて

従来のサービス指向アーキテクチャーの哲学の1つは、ドメインと運用の両方で、可能な限り多くの機能を再利用することでした。
それによりたった一つの中央集権的なコンポーネントが発生し、監視などを行います。

マイクロサービスアーキテクチャは違います。

アーキテクトはこれら2つの懸念(ドメインと運用)を分割しようとするのです。
つまり、**それぞれのサービスごとに運用の機能を持たせます**

このパターンをsidecarパターンと読んでいます。

<img src="https://camo.githubusercontent.com/14cbd02ec0aa01eb3de29b38a170208c2e3b1429b766c801e6e36358c023980d/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313730322e706e67">


仮に運用チームという体制が存在する場合、sidecarとなっている監視用のパネルを集約することも可能です。


<img src="https://camo.githubusercontent.com/9c5d2503680a404b331f7641d0156dd2877aa64eccd0e6f51630aa2ebbc5ad0e/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313730332e706e67">


各サービスの呼び出し状況を把握するための方法はもう一つあります。

**各サービスを直接呼び出すのではなく、サービス検知ツールを経由します**

このツールは、リクエストの数と頻度を監視し、サービスの新しいインスタンスを起動して、規模や弾力性の問題を処理します。

このようにしてマイクロサービスアーキテクチャはサービスの弾力性を維持するのです。



## フロントエンド

ここまではマイクロサービスアーキテクチャのバックエンドの話をしてきました。

ユーザーインターフェースがモノシリックである場合、各サービスはAPIを通して呼ばれます。

<img src="https://camo.githubusercontent.com/a312657618829a4a49e3065a21fd01abe26baf8cdf8afd5992b63d54afb947c9/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313730352e706e67">

しかしこれはマイクロサービスアーキテクチャの理想とは少し異なります。

マイクロサービスアーキテクチャでは**フロントエンドでも高度な分離を要求するのです。**

<img  width="70" src="https://camo.githubusercontent.com/6b174fa582571100328001126c6f3adfe40466c228cbdad98d11556425b47acd/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313730362e706e67">



## 備考

title:マイクロサービスアーキテクチャのメリットとデメリット

description:マイクロサービスは分散アーキテクチャを形成し、各サービスは独自のプロセスで実行されます。これは元々は物理コンピューターを意味していましたが、すぐに仮想マシンとコンテナーに進化しました。

img:https://github.com/kawadasatoshi/techblog/blob/main/0/inhouse_se/2008microservice_arch/microservice_arch.png?raw=true

category_script:( page_name.startswith("2") or page_name.startswith("1") )










