

## 参考

「FundamentalsOfSoftwareArchitecture.md」という記事を参考にしてます。

https://github.com/zhangjunhd/reading-notes/blob/master/software/FundamentalsOfSoftwareArchitecture.md#13service-based-architecture-style

ちなみのこの記事は「ソフトウェアアーキテクチャの基礎」という書籍の関連資料である。

<img src="https://camo.githubusercontent.com/d799cbb6d1ed1f01ab09bf1d78b29527875119b278387f64b1b583bb40458958/68747470733a2f2f696d67312e646f7562616e696f2e636f6d2f766965772f7375626a6563742f732f7075626c69632f7333333332313737382e6a7067">



## なぜイベント駆動アーキテクチャを採用するのか？

イベント駆動型アーキテクチャスタイルは、非同期通信のみに依存するという点で、他のアーキテクチャスタイルに比べて独自の特徴を提供します。

非同期通信は、システムの全体的な応答性を向上させるための強力な手法です。

<img src="https://camo.githubusercontent.com/620e2bf27e102e06a73c76c82171d2c9a6779ab709d83e1b07ec1fe41f43c95e/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313431332e706e67">

イベント駆動アーキテクチャは高度にスケーラブルで高パフォーマンスなアプリケーションを実現できる。

また、適応性に優れており、小規模なアプリにも大規模なアプリにも使うことができる




## イベント駆動アーキテクチャの構成

イベント駆動アーキテクチャは分散非同期型のアーキテクチャスタイルです。

このアーキテクチャを実装したアプリケーションは、いわゆる要求ベースのモデルに従います。

まずこのモデルではシステムに対して行われた要求は全て、要求オーケストレーターに送信されます。

リクエストオーケストレーターはユーザーインターフェイスですが、APIレイヤーとして実装することもでき、
主な役割はさまざまなリクエストプロセッサーにリクエストを同義的かつ同期的に送信することです。

要求プロセッサは、データベース内の情報を取得または更新して、要求を処理します。

以下にその図を示します。

<img src="https://camo.githubusercontent.com/5fa13d62667b078243172113f9340d6658fa2f894f1339b90edc8cfb1f503963/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313430312e706e67">



## イベント駆動アーキテクチャの概要

イベント駆動アーキテクチャには、メディエータートポロジとブローカートポロジの2タイプがあります。

- メディエータートポロジは、イベントプロセスのワークフローを制御する必要がある場合に一般的に使用されます。

<img src="https://camo.githubusercontent.com/59703049a036a41273bf983d1588a848d28a299e62859b9346ff0ded14ce3b5f/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313430322e706e67">

- ブローカートポロジは、イベントの処理に対して高度な応答性と動的制御を必要とする場合に使用されます。

<img src="https://camo.githubusercontent.com/181738642248b61b9eb085c80196d251b38702d7f9e56c3a94ad72a3aaf1395a/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313430352e706e67">


## イベント駆動アーキテクチャ - ブローカータイプ -

ブローカートポロジは、中央イベントメディエーターがないという点でメディエータートポロジとは異なります。

よく使われるのは、

- オンラインオークションに入札するような単純なイベント
- 転職や結婚などの健康給付システムにおけるより複雑なイベント

などです。

## ブローカータイプの構造

開始イベントは、処理のためにイベントブローカーのイベントチャネルに送信されます。

イベントを管理および制御するブローカー・トポロジーでは、単一のイベント・プロセッサーがイベント・ブローカーからの開始イベントを受け入れ、そのイベントの処理を開始します。

開始イベントを受け入れたイベントプロセッサは、そのイベントの処理に関連する特定のタスクを実行し、処理イベントと呼ばれるものを作成することによって、システムの残りの部分にそれが行ったことを非同期的に連絡します。

この処理イベントは、必要に応じてさらに処理するためにイベントブローカーに非同期で送信されます。

他のイベントプロセッサは、処理イベントをリッスンし、何かを実行してそのイベントに反応し、新しい処理イベントを介して実行したことをアドバタイズします。

このプロセスは、最終的なイベントプロセッサが何をしたかに誰も興味がなくなるまで続きます。

<img src="https://camo.githubusercontent.com/59703049a036a41273bf983d1588a848d28a299e62859b9346ff0ded14ce3b5f/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313430322e706e67">

## ブローカータイプのメリット

他のイベントプロセッサがそのアクションが何であるかを気にするかどうかに関係なく、各イベントプロセッサのブローカートポロジ内で、システムの残りの部分にそれが行ったことをアドバタイズすることはとても良い設計です。

なぜならこの方法は、そのイベントの処理に追加の機能が必要な場合に、アーキテクチャの拡張性を提供します。

ex) たとえば、複雑なイベントプロセスの一部として、電子メールが生成され、実行された特定のアクションを顧客に通知するとします。

通知イベントプロセッサは、電子メールを生成して送信し、トピックに送信された新しい処理イベントを通じて、そのアクションをシステムの残りの部分に連絡します。

ただし、この場合、他のイベントプロセッサはそのトピックに関するイベントをリッスンしていないため、メッセージは単に消えます。

<img src="https://camo.githubusercontent.com/d4bd92486e086815436e9c4e434f4ef7402e559136108e71a68585ae396663cf/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313430332e706e67">

これは、アーキテクチャの拡張性の良い例です。

無視されるメッセージを送信するリソースの浪費のように見えるかもしれませんが、そうではありません。

ex) 例えばここで、顧客に送信された電子メールを分析するための新しい要件が発生したとします。

この新しいイベントプロセッサは、インフラストラクチャを追加したり、他のイベントプロセッサに変更を適用したりすることないです。

電子メールトピックを介して新しいアナライザに電子メール情報を提供できるため、最小限の労力でシステム全体に追加できます。


## メディエイターパターンとは

イベントメディエーターは前節で説明したブローカートポロジーの欠点をいくつか解消できる。

イベントメディエーターパターンの中心には常に「イベントメディエーター」というコンポーネントが存在する。

<img src="https://camo.githubusercontent.com/181738642248b61b9eb085c80196d251b38702d7f9e56c3a94ad72a3aaf1395a/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313430352e706e67">

このイベントメディエーターは、イベント処理に必要なステップのみを知っており、対応する処理イベントを生成してP2Pのメッセージング方式でイベントチャネルに送信する。

イベントチャネルは受け取ったメッセージをもとに処理を実施するが、完了した報告をイベントメディエーターに行う。


## イベント駆動アーキテクチャのエラー処理

コンポーネント同士で意思の疎通が取れない場合はどうすれば良いか。

それは以下のように、エラー時に通常のコンポーネントではなく、エラーを処理するコンポーネントに送ることで対応が可能である。

<img src="https://camo.githubusercontent.com/0412b154b110745c55fbaad3524b4a13902a39d354cd0970a0b998f8cd55fda6/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313431342e706e67">

エラーを処理するコンポーネントでは、通常GUIとしてダッシュボードなどに表示される。

ダッシュボードにはエラーメッセージと、エラーを起こした処理が表示される。

このエラーを人間が手で修正し、再度エラーを起こしたコンポーネントに送信することで処理が可能である。


## イベント駆動アーキテクチャの総評

ワークフローの確実性と制御が必要な場合は、適切に構造化されたデータ駆動型のリクエスト（顧客プロファイルデータの取得など）に対してリクエストベースのモデルを選択することをお勧めします。

例えば、ECの注文処理など。

複雑で動的なユーザー処理を伴う、高レベルの応答性とスケールを必要とする柔軟なアクションベースのイベントには、イベントベースのモデルを選択しましょう。

<img src="https://camo.githubusercontent.com/85abc7ad3f27c612cd839e532b0b2bcfd00a45888cb09f18282bcf2be7bc9ff3/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313432322e706e67">



## 備考

title:イベント駆動アーキテクチャのメリットとデメリット

description:イベント駆動型アーキテクチャスタイルは、非同期通信のみに依存するという点で、他のアーキテクチャスタイルに比べて独自の特徴を提供します。非同期通信は、システムの全体的な応答性を向上させるための強力な手法です。

img:https://camo.githubusercontent.com/5fa13d62667b078243172113f9340d6658fa2f894f1339b90edc8cfb1f503963/68747470733a2f2f6c6561726e696e672e6f7265696c6c792e636f6d2f6c6962726172792f766965772f66756e64616d656e74616c732d6f662d736f6674776172652f393738313439323034333434372f6173736574732f666f73615f313430312e706e67

category_script:page_name.startswith("2")

