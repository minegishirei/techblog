

**docker runコマンドは今のところdockerシステムの中で最も複雑なコマンドのうちの一つとなってます。**

docker runコマンドで引数を使用すると、ユーザーはイメージの実行方法を編集することができます。
具体的にはrunコマンドのオプションで、dockerコンテナのライフサイクルをコントロールできます。


### Docker入門 関連記事

- [Docker入門](https://minegishirei.hatenablog.com/entry/2023/09/02/213936)
- [Dockerのダウンロードとインストール(Mac編)](https://minegishirei.hatenablog.com/entry/2023/09/03/143528)
- [Dockerのダウンロードとインストール(Windows編)](https://minegishirei.hatenablog.com/entry/2023/09/04/115946)
- [Dockerのプロキシーの設定](https://minegishirei.hatenablog.com/entry/2023/09/05/120827)



# dockerのrunコマンドのオプション一覧

[:contents]

## docker -a --attachとは:コンテナ内部のコンソール画面への出力をホストマシンに保存する

Dockerの `docker run` コマンドで使用される `-a` オプションは、コンテナ内で実行されるコマンドの標準出力と標準エラー出力をホストマシンに保存するために使用されます。

以下は、 `docker run` コマンドで `-a` オプションを使用する例です。

```sh
docker run -a stdout -a stderr <イメージ名> <コマンド>
```

このコマンドは、指定されたイメージを使用してコンテナを作成し、指定されたコマンドを実行しますが、`-a` オプションに `stdout` と `stderr` を指定することにより、**コンテナの標準出力と標準エラー出力をホストマシンに保存することができます。**

**保存されたログは、`docker logs`コマンドを使用して後で表示することができます。** 例えば、以下のコマンドを使用してログを表示できます。

```sh
docker logs <コンテナID>
```

また、 **`-a` オプションには、出力を保存する場所を指定するためのパスも指定することができます。** 例えば、以下のコマンドを使用して出力を保存する場所を指定することができます。

```sh
docker run -a stdout:/path/to/stdout.log -a stderr:/path/to/stderr.log <イメージ名> <コマンド>
```

このコマンドは、指定されたイメージを使用してコンテナを作成し、指定されたコマンドを実行します。 `-a` オプションには、 `stdout` と `stderr` の出力をそれぞれ `/path/to/stdout.log` と `/path/to/stderr.log` に保存するように指示されています。
- 指定しない場合は、両方(stdoutとstderr)が付属しています。

- 指定されていない状態でコンテナが起動で開始された場合、インタラクティブモード（-i）、stdinも付属しています。

-dと互換性はありません


## docker -d --detachとは:バックグランド実行

コンテナを「デタッチ」モードで実行します。

例えば**awsのec2にsshで入った後、webサーバーをバックグラウンドプロセスとして動かし続けたい場合に有用です。**

以下は、 `docker run` コマンドで `-d` オプションを使用する例です。

```sh
docker run -d <イメージ名> <コマンド>
```

このコマンドは、指定されたイメージを使用してコンテナを作成し、指定されたコマンドをバックグラウンドで実行します。

このようにして作成されたコンテナは、コンテナの実行状態を確認するために `docker ps` コマンドを使用することができます。例えば、以下のコマンドを使用して、バックグラウンドで実行されているコンテナの一覧を表示することができます。

```sh
docker ps
```

また、バックグラウンドで実行されているコンテナのログを表示するには`-a`オプションの解説と同様 `docker logs` コマンドを使用します。例えば、以下のコマンドを使用して、バックグラウンドで実行されているコンテナのログを表示することができます。

```sh
docker logs <コンテナID>
```

なお、 `-d` オプションは、**対話型のコンテナを実行する場合には使用できません。**
対話型のコンテナを実行する場合は、代わりに `-it` オプションを使用する必要があります。


## docker -itオプション:コンテナと対話的なシェルを立ち上げたい。

`-it`フラグは、**コンテナ内部とやりとりするためのコマンド**で、`bash`コマンドと組み合わせることで、ssh接続されたかのように、コンテナ内部からLinuxコマンドを実行することができます。

たとえば、flaskサーバーを起動した後にbashシェルを起動したい場合は、以下のように`-it`を組み合わせることで対話的なシェルが立ち上がります。

```sh
docker run -it -p 80:80 -v ./code:/code flask bash
```

###  -t --ttyオプション

疑似TTYを割り当てます。(ターミナルとして起動可能であること)



## docker --rm:コンテナを残さない

コンテナが終了すると、コンテナを自動的に削除します。 
このオプションを使用することで、コンテナが終了した後に手動で削除する必要がなくなります。これは、一時的なタスクを実行するためのコンテナを作成する場合に便利です。

```sh
docker run --rm <イメージ名> <コマンド>
```

例えば、以下のコマンドは、 ubuntu イメージを使用して一時的なコンテナを作成し、 ls コマンドを実行します。このコンテナは、 --rm オプションにより、コマンドの実行後に自動的に削除されます。

```sh
docker run --rm ubuntu ls /
```

注意！：-dと一緒に使用することはできません。


## docker -e, --env:環境変数を指定する

Dockerの `docker run` コマンドで使用される `-e` オプションは、**コンテナ内で使用される環境変数を設定するために使用されます。**

以下は、 `docker run` コマンドで `-e` オプションを使用する例です。

```sh
docker run -e <環境変数名>=<値> <イメージ名> <コマンド>
```

このコマンドは、指定されたイメージを使用してコンテナを作成し、指定されたコマンドを実行します。また、 `-e` オプションを使用して、コンテナ内で使用される環境変数を設定することができます。

例えば、以下のコマンドは、 `nginx` イメージを使用してコンテナを作成し、 `MY_ENV_VAR` 環境変数に `my-value` という値を設定しています。

```sh
docker run -e MY_ENV_VAR=my-value nginx
```

このようにして作成されたコンテナ内で、 `MY_ENV_VAR` 環境変数を使用することができます。環境変数を使用する方法は、コンテナ内で実行されるアプリケーションによって異なりますが、通常は、環境変数を使用してアプリケーションの構成情報や認証情報を渡すことができます。

複数の環境変数を設定する場合は、 `-e` オプションを複数回指定することができます。また、環境変数の値には、別の環境変数を参照することもできます。例えば、以下のコマンドは、 `MY_ENV_VAR` 環境変数の値を `MY_OTHER_ENV_VAR` 環境変数に設定しています。

```sh
docker run -e MY_ENV_VAR=my-value -e MY_OTHER_ENV_VAR=$MY_ENV_VAR nginx
```

このようにして作成されたコンテナ内で、 `MY_OTHER_ENV_VAR` 環境変数に `my-value` という値が設定されます。


以下の例は、linuxのdebian系のディストリビューションosで`-e`で環境変数を指定した後、`env`コマンドで環境変数を確認しています。

```sh
$ docker run -e var1=val -e var2="val 2" debian env
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=b15f833d65d8
var1=val
var2=val 2
HOME=/root
```

**また、ファイルを介して変数を渡すための`--env-file`オプションも覚えておいてください。**





# 次のオプションを使用すると、コンテナ名と変数を設定できます。



## docker -h, --hostname

コンテナに名前をつけます。

例えば：

<pre><code>
$ docker run -h "myhost" debian hostname
myhost
</code></pre>


## docker -n --name

名前をコンテナに割り当てます。

その後、名前を使用してアドレス指定できます。

他のDockerコマンドのコンテナ。



# 次のオプションを使用すると、ユーザーはボリュームを設定できます

## docker -v --volume

ボリューム（ファイルまたはディレクトリ）を設定するための引数には2つの形式があります。



- 最初の形式は、コンテナ内のディレクトリのみを指定する形式であり、Dockerが選択したホストディレクトリにバインドします。 

- 2番目の形式はバインドするホストディレクトリもコンテナ内のディレクトリも両方指定します。


## docker --expose

DockerfileでのEXPOSE命令に相当します。

コンテナで使用されているポートまたはポート範囲を識別しますが、実際にはポートを開きません。 

オプションの-Pと関連付けて、コンテナをリンクする場合にのみ実際に意味があります。


## docker --link

指定されたコンテナへのプライベートネットワークインターフェイスを設定します。

詳細については、「コンテナのリンク」を参照してください。


## `docker -p --publish`:ポート番号を割り当てる

**コンテナのポートを「公開」し、ホストからアクセスできるようにします。**

docker runコマンドの `-p` オプションは、Dockerコンテナのポートとホストマシンのポートをマッピングするために使用されます。ホストマシンとDockerコンテナの間で通信を行うためには、ポートのマッピングが必要です。

`-p` オプションの一般的な構文は次のとおりです。

```sh
docker run -p <ホストマシンのポート>:<コンテナのポート>
```

`<ホストマシンのポート>` は、ホストマシンの特定のポート番号を指定します。ホストマシン上のこのポートを介してコンテナにアクセスできます。`<コンテナのポート>` は、コンテナ内の待ち受けるポート番号を指定します。

例えば、ホストマシンのポート8080をDockerコンテナのポート80にマッピングする場合、以下のように指定します。

```sh
docker run -p 8080:80 <イメージ名>
```

上記のコマンドを実行すると、ホストマシンのポート8080へのアクセスがDockerコンテナのポート80に転送されます。つまり、ホストマシンの `http://localhost:8080` にアクセスすると、Dockerコンテナ内のアプリケーションが応答します。

また、`-p` オプションは複数回指定することができます。複数のポートをマッピングする場合は、それぞれのポートマッピングをスペースで区切って指定します。

```sh
docker run -p 8080:80 -p 9000:9000 <イメージ名>
```

この場合、
- ホストマシンのポート8080がコンテナのポート80に
- ホストマシンのポート9000がコンテナのポート9000にマッピングされます。

ポートマッピングを使用することで、ホストマシンとDockerコンテナの間で通信を確立することができます。



## docker -P --publish-all

コンテナで公開されている**すべてのポート**をホストに公開します。

公開されているポートごとに、ランダムな番号の大きいポートが選択されます。

docker portコマンドを使用して、マッピングを確認できます。


## docker --restart:

Dockerが終了したコンテナーを再起動しようとするタイミングを構成します。

--restartコマンドはさらに引数をとるコマンドです。

- 引数を指定しない場合、dockerコンテナの終了ステータスに関係なく、再起動します。 

- 「--restart on-failure」引数は再起動を試みますが、コンテナがゼロ以外のステータスで終了し、オプションの引数を取ることができる状態でのみ再起動します。

たとえば、

<pre><code>
docker run --restart onfailure：10 postgres

</code></pre>

はpostgresコンテナを起動し、再起動を試みます。

ゼロ以外のコードで終了する場合は10回まで再起動します。





## まとめ

これ以外でも、より高度なネットワーキングを行う必要がある場合に役立つと思われるオプションがいくつかあります。

これらのオプションのいくつかでは、**ネットワークとそれがDockerでどのように実装されているかをある程度理解している必要がある**ことに注意してください。

また、docker runコマンドには、コンテナーの特権と機能を制御するための多数のオプションもあります。

次のオプションは、Dockerfile設定を直接オーバーライドします。

## docker --entrypoint

コンテナのエントリポイントを指定された引数に設定し、DockerfileのENTRYPOINT命令をオーバーライドします。

## docker -u --user

コマンドが実行されるユーザーを設定します。ユーザー名またはUIDとして指定できます。 

DockerfileのUSER命令をオーバーライドします。

## docker -w --workdir

コンテナ内の作業ディレクトリを指定されたパスに設定します。 Dockerfileの値をオーバーライドします。







## 備考

img:https://www.oreilly.co.jp/books/images/picture_large978-4-87311-776-8.jpeg

category_script:True

title:dockerのrunコマンドオプション一覧【docker入門】



