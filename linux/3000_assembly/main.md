

## アセンブリ言語とは


機械語の一個手前のプログラミング言語
C言語よりも低級。


### 具体例と用語

例えば

> 0x8bec 

は機械語であり、人間には読めないが

> MOC BX SP

は人間には何とか読める（SPをBXに代入せよという命令）
ここで、この一行の命令のことを**ニーモニック**と呼び、
これの集まりがアセンブリ言語である。

また、引数の一つ目を「第一オペラント」第二引数を「第二オペラント」と呼ぶ


https://www.youtube.com/watch?v=8EcHs4UGgMc

### サンプルコード（掛け算）

アセンブラでの掛け算は、アーキテクチャによって異なる方法があります。以下に、一般的なアセンブリ言語における掛け算の方法をいくつか紹介します。

1.  加算ループを使用する方法:
    この方法では、掛ける数を加算することで乗算を実現します。

```asm
; 例: AX = AX * BX

MOV CX, BX    ; BXをカウンタレジスタCXにコピー
MOV AX, 0     ; 結果を格納するレジスタAXを0に初期化

MUL_LOOP:
    ADD AX, CX    ; AXにCXを加算
    LOOP MUL_LOOP ; CXをデクリメントし、0でない場合はループ
```

- この例では、BXレジスタの値をAXレジスタに掛けます。
- CXレジスタはカウンタとして使用され、掛ける回数を表します。
- ループの中でAXにCXを加算し、CXをデクリメントします。
- CXが0になった時点でループを終了します。

要はBXの数だけAKを掛け合わせるということ。

2. CPUの掛け算を利用する方法
CPUによっては掛け算を用意してくれている。


### アセンブラ、アセンブリ、アセンブル

- アセンブラ；ソフトウェアのこと
- アセンブリ；言語のこと。
- アセンブル：動詞。

まとめると、**アセンブリをアセンブラでアセンブルする。**


### アセンブリ言語の大変なこと

アセンブリ言語はCPUと一対一対応している。
したがって、**CPUごとにニーモニックが異なる**
そのため、アセンブリ言語は断トツで断トツで難しい
覚える命令は少ないが...

コンパイル言語はさらに抽象化されているため、同じコードでCPUが動くし、言語がCPUによって変わることもない。


### アセンブリ言語のメリット

CPUの最適化ができるのがアセンブリ言語のメリット。
ただ、速度目的ではすでにコンパイラの最適化は素晴らしいことになっているので、人間がそこに介入する余地はない。

- コンピューターの気持ちが分かるようになる。
- アセンブラで動いているプログラムも0じゃない。そこではアセンブリ言語が必須。
- CPU開発
- カーネル、デバイスドライバ
- コンパイラ開発


## スタックとレジスタ

- まずはレジスタについて

レジスタ: プロセッサ内の小さなメモリ領域で、高速にアクセスできます。レジスタはデータやアドレスを一時的に格納するために使用されます。一般的なレジスタには、演算用の汎用レジスタ、アドレスを格納するためのインデックスレジスタ、フラグを格納するためのフラグレジスタなどがあります。

**要は実在するめっちゃ早いメモリということ。**

- 次にスタックについて



### 代入

代入には`mov`命令を使用する。

以下のケースでは
raxに0x1を代入している。
raxとはレジスタのことであり、CPU内部のメモリーであるレジスタに対して、0x1を代入しているという意味だ。

```asm
mov rax 0x1
```

ちなみに代入先の変数はすでにCPUが用意している`E~X`という変数に代入する。

- EAX: アキュムレータとして使用されるレジスタ。算術演算やデータの一時的な格納に使用されます。
- EBX: ベースレジスタとして使用されるレジスタ。メモリアドレスのオフセット計算に使用されることがあります。
- ECX: カウンタとして使用されるレジスタ。ループカウンタやカウンティング処理に使用されます。
- EDX: データレジスタとして使用されるレジスタ。一時的なデータの格納に使用されます。

ちなみに先頭の`E`は32bitのレジスタであるということを表しており、ここが`R`である変数もある。つまり、`RAX`,`RBX`,`RCX`,`RDX`も存在している。

### ジャンプ

C言語でいうところのgoto文。
非推奨だが、ループでめっちゃ使われる

引数はラベルかアドレスであり、そこの部分まで移動する。

```asm
jmp sub
jup 0xdeadbeef
```

ラベル: プログラム内の特定のアドレスを識別するためのシンボリックな名前です。ラベルは通常、ジャンプや分岐命令などの制御フローの制御に使用されます。

アドレス：この場合のアドレスもプログラム内のどこかの領域を指しており、そこまで移動する。

#### サンプルコード

raxに10を加算し続けるコードは以下の通り

```asm
mov rax,0x0
label:
    add rax,0xa
    jmp label
```

ちなみに、このコードは無限ループしてしまうので実行は非推奨。


### 比較

`cmp`と`je`を組み合わせて行う。

`cmp`は二つの引数の比較を行い、問題なければ`je`で指定したラベルに移動する。

```asm
cmp rax, 0x1
je label
```

内部的には、`cmp`は比較結果を`ZFレジスタ`と呼ばれる指定の個所に`フラグレジスタ`を格納する。
`je`はその結果を見てジャンプをするかどうか決める。

ちなみに、等しくない場合のジャンプ先は`jne`で指定する。

(jeはjump equal、jneはjump not equalという意味)


#### 比較を用いたストップ

```asm
mov rax,0x0
label:
    add rax,0xa
    jmp label
    cmp rax, 0x14
    je endlabel:
endlabel:
```

## 覚えるべきレジスタ

大量にレジスタが出てきたのでこの辺でどんなレジスタがあるかを一覧にする。

- rax:関数の戻り値
- rdi:関数の第一引数
- rip:次に実行する命令のアドレス
- rbp:スタックのベースのポインタ（要注意！）
- rsp:スタックのトップのポインタ（要注意！）


## スタックとは?

先ほど話した`rbp`レジスタと`rsp`レジスタがスタックそのものを表している。

- rはレジスタの略
- pはポインタの略
    - rbpのbはベースの略で、スタックの底を表す。
    新しいスタック領域が始まるたびにプログラムがセットする必要がある。
    - rspのsはスタックの略で、スタックのてっぺんを表す。
    popやpushのたびにポインタの値は変わる。

rspについて。

### push

レジスタの`rsp`を８バイト減らす。

```asm
sub rsp 0x8 (結果はraxに格納される)
mov [rsp] rax
```

`[`はc言語でいうところのポインタ参照。`[rsp]`と書くことで値を直接編集できる。
このようにして、アセンブラは現在参照しているポインタである`rsp`を増減しながら処理を先に進めることができる。


### pop

逆にpopはレジスタ`rsp`から8バイト増加させている。

```asm
add rsp 0x8
mov [rsp] rax
```

## スタックの使い方

先ほどの`rsp`に対する`push`と`pop`は関数呼び出しにつかわれる。
アセンブリでは関数を呼び出す`call`と実行結果を返す`ret`で構成されているが、それらの中身では`rsp`に対する`pop`と`push`が動いている

### callとretの挙動

`call`は
- 次の行のアドレスをスタックにpushする
- その後、callの引数にjumpする

という処理を行う。

その後、`ret`は
- `rip`に`pop`を行うことで、呼び出し元のアドレスを手に入れる
- アドレス先にjumpする







## アセンブリ用語集

### 命令セット

命令セット: プロセッサが実行可能な命令のセットです。命令セットはプロセッサごとに異なる場合があります。命令セットには算術演算、データ転送、条件分岐などの命令が含まれます。

1.  データ転送命令:
    * MOV: データをレジスタからレジスタ、メモリからレジスタ、レジスタからメモリに転送します。
    * PUSH: スタックにデータをプッシュします。
    * POP: スタックからデータをポップします。
2.  算術演算命令:
    * ADD: レジスタやメモリ上の値を足し合わせます。
    * SUB: レジスタやメモリ上の値を引きます。
    * MUL: レジスタやメモリ上の値を掛けます。
    * DIV: レジスタやメモリ上の値で割ります。
3.  制御フロー命令:
    * JMP: 指定したアドレスにジャンプします。
    * CMP: 2つの値を比較します。
    * JE / JZ: 直前の比較が等しい場合にジャンプします。
    * JNE / JNZ: 直前の比較が等しくない場合にジャンプします。
    * JL / JNGE: 直前の比較が未満の場合にジャンプします。
    * JG / JNLE: 直前の比較がより大きい場合にジャンプします。
4.  ループ命令:
    * LOOP: ループカウンタをデクリメントし、指定のラベルにジャンプします。
    * INC: レジスタやメモリの値をインクリメントします。
    * DEC: レジスタやメモリの値をデクリメントします。

### レジスタ


メモリ: データや命令を格納する場所です。メモリはアドレスによって識別され、プログラムやデータの読み書きが行われます。

ラベル: プログラム内の特定のアドレスを識別するためのシンボリックな名前です。ラベルは通常、ジャンプや分岐命令などの制御フローの制御に使用されます。

ディレクティブ: アセンブラに対する命令であり、コンパイラによって処理されます。ディレクティブは、メモリの配置、定数の定義、インクルードファイルの指定など、コンパイル時に実行される指示を提供します。

ラベルと命令の組み合わせ: Assemblyプログラムは、ラベルと命令の組み合わせで構成されます。ラベルは命令のメモリ上の場所を識別し、命令はプロセッサに対して実行されます。プログラムは、シーケンシャルに実行される場合もありますが、条件分岐やループなどの制御フローもサポートされます。



## アセンブリ言語の基本命令セット

アセンブリ言語は、コンピュータアーキテクチャの命令セットに基づいて機械語命令を表現するための低レベルのプログラミング言語です。以下に、一般的なアセンブリ言語の基本的な命令をいくつか示しますが、具体的なアーキテクチャによって異なる場合があります。

1.  データ転送命令（Move Instructions）:
    * MOV: データをメモリからレジスタ、レジスタからメモリ、レジスタからレジスタへ転送します。
    * LDR: メモリからデータを読み込み、レジスタに格納します。
    * STR: レジスタの内容をメモリに書き込みます。
2.  算術・論理演算命令（Arithmetic/Logical Instructions）:
    * ADD: レジスタに値を加算します。
    * SUB: レジスタから値を減算します。
    * AND: レジスタと値の論理積を計算します。
    * OR: レジスタと値の論理和を計算します。
3.  制御命令（Control Instructions）:
    * JMP: プログラムの指定された場所にジャンプします。
    * CMP: レジスタの値を比較します。
    * JZ (Jump if Zero): Zフラグがセットされている場合に指定された場所にジャンプします。
4.  ループ制御命令（Loop Control Instructions）:
    * LOOP: ループのカウンタをデクリメントし、カウンタが0でない場合に指定された場所にジャンプします。
    * CMPとJZを組み合わせて使用することもあります。
5.  スタック操作命令（Stack Operation Instructions）:
    * PUSH: レジスタの内容をスタックにプッシュします。
    * POP: スタックから値をポップし、レジスタに格納します。

これらは一般的なアセンブリ言語の命令の一部です。実際のアーキテクチャやアセンブリ言語の詳細によって、他の命令や異なる構文が存在する場合があります。具体的なアセンブリ言語に関しては、対象とするアーキテクチャのドキュメントやリファレンスを参照してください。





レジスタ数

from https://www.youtube.com/watch?v=95WZlyJUppk










