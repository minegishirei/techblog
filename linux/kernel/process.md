


## Linuxカーネルのプロセス

### ユーザープロセスについて

ユーザープロセスとは文字通り、ユーザーの操作が元となり発生するプロセスのことです。

- ユーザーモードとカーネルモードを切り替えるための特別な命令がCPUには用意されています。
- そして、プログラムは大部分の時間がユーザーモードで実行されるため、カーネルモードに切り替わるのは、カーネルが提供するサービスを要求する場合のみです。ユーザーモードで実行されているときには、プログラムはカーネルデータやカーネルコードにアクセスすることはできません。

- カーネルのサービスを必要とするプロセスは、システムコールと呼ばれるプログラミング手続きでアクセスします。この命令をする際にはカーネルモードに切り替えるCPU命令を実行した後でなければなりません。


### カーネルスレッド

ユーザープロセス以外にも、カーネルスレッドと呼ばれる特別なプロセスがあります。

- システムの起動時に生成され、シャットダウンされるまで動作する
- ユーザとのやり取りはないため、端末デバイスがいらない
- カーネルアドレス空間にて、カーネルモードで動作する
    - ex) プロセスＩＤが1の`init`プロセスなど


### Linuxカーネルのそのほかの役割

- プロセスによるシステムコール
- 例外信号の発生。（命令が無効な場合など、何かしら異常な状態の処理）
- 周辺デバイスからCPUへの割り込み信号の発行。ＣＰＵの状態を注意するものや状態の変更などの事象を知らせるものであり、各割り込み信号あh、**割り込みハンドラ**と呼ばれるカーネルプログラムによって処理されます。
- カーネルスレッドの実行。



## プロセスの切り替え

カーネルはプロセスの実行を停止する際、その時点でのプロセッサレジスタの内容をプロセスディスクリプタの中に退避します。
この機能により、すべてのUNIXカーネルは、**再入可能（リエントラント）**です。
これによりCPUは各プロセスを高速で切り替えながら処理を進めるので、実質的に同時に複数のプロセスをカーネルモードで実行することができます。

例えば

> プロセスに代わってディスクからの読み取り要求を発行した後、カーネルはその仕事をディスクコントローラーに任せ、ほかのプロセスの実行を再開します。
> デバイスが読み取りを完了すると、割り込みによってカーネルに通知します。


### 再入可能性(理エントラント)なシステムコールの実現方法

- ローカル変数だけを変更し、グローバル変数を変更しないような関数を書くこと
- カーネルはグローバル変数に対してロック機能を使い、その関数を実行するプロセスがその時点で一つだけであることを保証します。

### どんな時に複数のカーネル実行パスを切り替えるのか?

カーネル実行パスとは、システムコール、例外、割り込みを処理するためにカーネルによって実行される命令シーケンスのことです。

最も単純な場合、ＣＰＵは一つのカーネル実行パスを最初から最後まで逐次的に実行しますが、以下の事象が発生した場合はＣＰＵは複数のカーネル実行パスを切り替えながら実行します。

- A:ユーザーモードで実行中のプロセスによってシステムコールが発行されたが、カーネル実行パスではその要求を即座に完了できない場合。
この場合、新しい実行プロセスを選ぶためにスケジューラを起動します。
- B:カーネル実行パスを実行中、ＣＰＵが例外を発生した場合。CPUは実行中のプロセスを一時停止し、対応する新たなプロセスを開始する。この処理が終了すると、最初の実行パスを再開できる。
- C:割り込み許可されたカーネル実行パスを実行中に、ハードウェア割り込みが発生した場合。ハードウェアの処理を優先し、処理が完了すれば最初の処理に戻る。




## メモリ内部の動き（プロセスアドレス空間）

プロセスは基本的にはそれぞれの固有なアドレス空間において実行されます。

- ユーザーモードプロセスは、固有のスタック、データ、コード領域を参照します。
- カーネルモードプロセスは、カーネルのデータとコード領域を参照し、もう一つの固有スタックを使用します。

しかし、各プロセスが固有のアドレスう空間にアクセスしているかのように見えていても、固有のアドレス空間の一部が複数のプロセスによって共有されている場合もあります。

> 同時に複数のユーザーによって同じプログラム（エディタなど）が必要とされている場合、そのプログラムがメモリに読み込まれるのは一度だけです。

この種のアドレス空間の共有は、メモリの節約のためにカーネルが自動的に行います。




## シグナル

UNIXの**シグナル**は、プロセスに対する通知です。
シグナルは20種類ほど存在し、通常は`SIGTERM`のようなグローバル変数、マクロ名によって参照されます。

### 非同期と同期

シグナルは大きく分けて2つに大別できます。

- 非同期通知
    > ex) ユーザーは割り込みキーコード（Ctrl+C, Ctrl+Z）を入力することにより、割り込み信号`SIGINT`をフォアグラウンドプロセスに送ることができます。
- 同期通知
    > プロセスが無効なアドレスのメモリ位置にアクセスしようとした場合、カーネルはプロセスに対し、シグナル`SIGSERG`を送ります。

### 受信時の反応

一般的に、シグナル受信時のプロセスの対応は次のどちらかの選択肢が考えられます。

- シグナルを無視する。（プログラムは通常は何もしないという選択をする）
- 非同期的に特定の手続きをする（プログラムはシグナル受信時に事前に決めた処理をする）

プロセスがこの二つをどちらも指定していない場合。次の5つの対応が設定されます。

- プロセスを終了する
- 実行コンテキストとアドレス空間の内容をファイルに書き込み、プロセスを終了する（**コアダンプ**ともいう）
- シグナルを無視する
- プロセスを停止する
- プロセスが停止していた場合、再開する


## IPC資源(プロセス間通信)

IPCとは、**プロセス間通信**という意味である。

POSIXが定めるプロセス間通信は三つの種類があり、それぞれメリットデメリットがある。

- メッセージキュー
- メモリ共有
- セフォマ


### メッセージキュー




from https://lightning-brains.blogspot.com/2019/08/unix-linux.html



### メモリ共有



















































